# Итератор

*Описан в GoF (стр. 249), относится к паттернам поведения объектов.*

Оригинальное описание: предоставляет способ последовательного доступа ко всем элементам составного объекта,
не раскрывая его внутреннго представления.

## Составной объект

Составные объекты состоят из других объектов. Иногда их называют *Агрегатами*.

Когда мы говорим о составных объектах в контексте *Итератора*, то имеем в виду *массивы*, *списки*, *двоичные деревья*,
*строки символов*. Все такие агрегаты состоят из элементов одного типа. Количество элементов не фиксировано, то есть мы
заранее не знаем, сколько символов окажется в строке.

Есть также *структуры*, они же *записи*, они же *кортежи*, которые могут состоять из объектов разного типа,
количество которых известно уже на этапе создания программы. К таким структурам данных паттерн *Итератор* неприменим.

> Итератор используется, когда количество элементов агрегата неизвестно, и все они имеют один и тот же тип.

## Причина появления

Существует круг задач, которые требуют полного или частичного перебора элементов агрегата, например, поиск максимального
элемента в массиве, поиск символа в строке, подсчёт суммы элементов списка.

Эти задачи решаются по разному в зависимости от составного объекта.

**Суммируем элементы массива**
```c
int sum(const int* start, size_t len)
{
  int result = 0;
  const int *end = start + len;
  
  for (const int* i = start; i < end; i++)
    result += *i;
    
  return result;
}
```

**Считаем длину строки**
```c
size_t strlen(const char* s)
{
  size_t result = 0;
  
  while (*s++)
    result++;
    
  return result;
}
```

**Ищем элемент в линейном однонаправленном списке**
```c
struct NODE
{
  NODE* next;
  int element;
};

NODE* find(NODE* head, int element)
{
    for (NODE* i = head, i != NULL && i->element != element; i = i->next)
      ;
      
    return i;
}
```

Проблема в том, что мы не можем написать обобщённый алгоритм поиска элемента или суммирования элементов. Мы должны точно знать,
с каким агрегатом мы работаем. Из-за этого нам придётся писать много похожего кода.
([Запах Duplicate Code](https://sourcemaking.com/refactoring/smells/duplicate-code)).

> С помощью итераторов мы можем писать обобщённые алгоритмы, которые работают с составными объектами любого типа.
> Надо всего лишь, чтобы мы могли получить итератор у составного объекта.

## Паттерны это не конкретные решения, это принципы

Паттерн *Итератор* может быть реализован разными способами. Сравните существующие подходы.

### Java

```java
public interface Iterable<T>
{
  Iterator<T> iterator();
}

public interface Iterator<E>
{
  E next();
  
  boolean hasNext();
  
  void remove();
}
```

В Java агрегаты элементов типа `T` должны реализовывать интерфейс `Iterable<T>`. Вызов метода `iterator()` создаёт новый
итератор, с помощью которого можно перебрать все элементы агрегата.

Для перебора используются методы `hasNext()` и `next()`:

```java
Iterator<int> i = aggregate.iterator();
int result = 0;

while (i.hasNext())
  result += i.next();
```

Метод `remove()` используется для удаления элемента из агрегата. Предполагается, что речь идёт о безопасном удалении.

### C\#

```c#
public interface IEnumerable<out T>
{
  IEnumerator<T> GetEnumerator();
}

public interface IEnumerator<out T>
{
  T Current { get; }
  
  bool MoveNext();
  
  void Reset();
}
```

В C# агрегаты типа `T` реализуют интерфейс `IEnumerable<T>`, который предоставляет метод `GetEnumerator()`.

```c#
IEnumerator<int> i = aggregate.GetEnumerator();
int result = 0;

while (i.MoveNext())
  result += i.Current;
```

Метод `Reset()` позволяет начать перебор с самого начала.

### C++

```c++
template<class T>
class iterator
{
public:
  T& operator*() = 0;
  
  iterator& operator++() = 0;
  
  bool operator!=(const vector_iterator& right) const = 0;
};
```

В C++ нет интерфейса, который должны реализовывать все агрегаты, вместо этого каждый агрегат предоставляет тип итератора и
метод для создания итератора. Перебор элементов целочисленного вектора:

```c++
iterator<int> i = aggregate.begin()
int result = 0;

while (i != aggregate.end())
  result += *i++;
```

Метод `begin()` возвращает новый итератор, а метод `end()` позволяет узнать, что элементов для перебора больше нет.
Итераторы в C++ поддерживают операторы `++`, `*` и `!=`, благодаря которым работа с итератором выглядит, как код на старом добром C.

### Сравнивая подходы

Детали реализации *Итератора* могут отличаться в широких пределах. Отметим основные моменты, а также плюсы и минусы разных решений.

1. В Java и C# есть интерфейс для агрегата и интерфейс для итератора. Благодаря интерфейсу агрегата можно использовать
   синтаксис `foreach`. Если у агрегата есть несколько способов обхода, этот метод
   работает плохо. Скажем, деревья можно обходить в глубину и в ширину. Один из этих способов мы реализуем, как основной,
   а для второго придётся придумывать нестандартное решение.

2. В C++ есть только интерфейс итератора, а агрегаторы предоставляют методы для создания итераторов. Агрегат типа `vector<T>`
   предоставляет методы `begin()`, `cbegin()`, `rbegin()` и `crbegin()`. Парные им методы `end()`, `cend()`, `rend()`, `crend()`
   нужны для завершения работы итераторов. Такой подход позволяет естественным образом предоставлять разные способы обхода
   агрегата. За это мы платим тем, что используем сложный синтаксис `for` вместо простого `foreach`.

3. В Java и C# методы `next()` и `MoveNext()` не только переходят к следующему элементу, но и возвращают значение. В Java это
   следующий элемент агрегата, а в C#&nbsp;&mdash; индикатор, что в агрегате есть ещё элементы. Роберт Мартин в книге &laquo;Чистый
   код&raquo; пишет, что такие функции нарушают принцип **функция должна выполнять одну операцию** (G30, стр. 341). Если будете
   реализовывать свой *Итератор*, вспомните об этом. Чтобы быть &laquo;чистым&raquo; *Итератор* должен предоставлять три операции:
   ```c#
   public interface IIterator<T>
   {
     T Current { get; }

     bool HasNext { get; }

     void MoveNext();
   }
   ```

4. Паттерн *Итератор* не требует методов `remove()` и `Reset()`, которые описаны в Java и C#. Эти методы нарушают принципы *Interface
   segregation* и *Liskov substitution*. В первом случае интерфейс предоставляет функции из разных сценариев, которые можно разнести
   в разные интерфейсы. Из-за этого часть наших реализаций будет генерировать исключение `NotImplementedException`, что нарушает второй
   принцип.

## Иногда агрегата может не быть

Концепция *Итератора* не ограничивается реальным *Агрегатом*. Иногда *Агрегат* может быть виртуальным, таким как
*множество чисел Фибоначчи*:

```c#
public IEnumerable<int> Fibonacci()
{
  int a = 0;
  int b = 1;

  while (a < int.MaxValue - b)
  {
    var t = b;
    b += a;
    a = t;
    yield return a;
  }

  yield return b;
}
```

Не смотря на то, что в коде нет составного объекта, который хранил бы числа Фибоначчи, *Итератор* ведёт себя так, будто
такой объект есть. Паттерн *Итератор* включает и такие сценарии.
